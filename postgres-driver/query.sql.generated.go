// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: query.sql

package postgresdriver

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"

	"github.com/lib/pq"
)

const activateBlockchain = `-- name: ActivateBlockchain :exec
UPDATE blockchains
SET active = $2
WHERE blockchain_id = $1
`

type ActivateBlockchainParams struct {
	BlockchainID string       `json:"blockchainID"`
	Active       sql.NullBool `json:"active"`
}

func (q *Queries) ActivateBlockchain(ctx context.Context, arg ActivateBlockchainParams) error {
	_, err := q.db.ExecContext(ctx, activateBlockchain, arg.BlockchainID, arg.Active)
	return err
}

const insertAppLimit = `-- name: InsertAppLimit :exec
INSERT into app_limits (application_id, pay_plan, custom_limit)
VALUES ($1, $2, $3)
`

type InsertAppLimitParams struct {
	ApplicationID string        `json:"applicationID"`
	PayPlan       string        `json:"payPlan"`
	CustomLimit   sql.NullInt32 `json:"customLimit"`
}

func (q *Queries) InsertAppLimit(ctx context.Context, arg InsertAppLimitParams) error {
	_, err := q.db.ExecContext(ctx, insertAppLimit, arg.ApplicationID, arg.PayPlan, arg.CustomLimit)
	return err
}

const insertApplication = `-- name: InsertApplication :one
INSERT into applications (
        application_id,
        user_id,
        name,
        contact_email,
        description,
        owner,
        url,
        status,
        dummy
    )
VALUES (
        $1,
        $2,
        $3,
        $4,
        $5,
        $6,
        $7,
        $8,
        $9
    )
RETURNING created_at, updated_at
`

type InsertApplicationParams struct {
	ApplicationID string         `json:"applicationID"`
	UserID        sql.NullString `json:"userID"`
	Name          sql.NullString `json:"name"`
	ContactEmail  sql.NullString `json:"contactEmail"`
	Description   sql.NullString `json:"description"`
	Owner         sql.NullString `json:"owner"`
	Url           sql.NullString `json:"url"`
	Status        sql.NullString `json:"status"`
	Dummy         sql.NullBool   `json:"dummy"`
}

type InsertApplicationRow struct {
	CreatedAt time.Time `json:"createdAt"`
	UpdatedAt time.Time `json:"updatedAt"`
}

func (q *Queries) InsertApplication(ctx context.Context, arg InsertApplicationParams) (InsertApplicationRow, error) {
	row := q.db.QueryRowContext(ctx, insertApplication,
		arg.ApplicationID,
		arg.UserID,
		arg.Name,
		arg.ContactEmail,
		arg.Description,
		arg.Owner,
		arg.Url,
		arg.Status,
		arg.Dummy,
	)
	var i InsertApplicationRow
	err := row.Scan(&i.CreatedAt, &i.UpdatedAt)
	return i, err
}

const insertBlockchain = `-- name: InsertBlockchain :one
INSERT into blockchains (
        blockchain_id,
        active,
        altruist,
        blockchain,
        blockchain_aliases,
        chain_id,
        chain_id_check,
        description,
        enforce_result,
        log_limit_blocks,
        network,
        path,
        request_timeout,
        ticker
    )
VALUES (
        $1,
        $2,
        $3,
        $4,
        $5,
        $6,
        $7,
        $8,
        $9,
        $10,
        $11,
        $12,
        $13,
        $14
    )
RETURNING created_at, updated_at
`

type InsertBlockchainParams struct {
	BlockchainID      string         `json:"blockchainID"`
	Active            sql.NullBool   `json:"active"`
	Altruist          sql.NullString `json:"altruist"`
	Blockchain        sql.NullString `json:"blockchain"`
	BlockchainAliases []string       `json:"blockchainAliases"`
	ChainID           sql.NullString `json:"chainID"`
	ChainIDCheck      sql.NullString `json:"chainIDCheck"`
	Description       sql.NullString `json:"description"`
	EnforceResult     sql.NullString `json:"enforceResult"`
	LogLimitBlocks    sql.NullInt32  `json:"logLimitBlocks"`
	Network           sql.NullString `json:"network"`
	Path              sql.NullString `json:"path"`
	RequestTimeout    sql.NullInt32  `json:"requestTimeout"`
	Ticker            sql.NullString `json:"ticker"`
}

type InsertBlockchainRow struct {
	CreatedAt time.Time `json:"createdAt"`
	UpdatedAt time.Time `json:"updatedAt"`
}

func (q *Queries) InsertBlockchain(ctx context.Context, arg InsertBlockchainParams) (InsertBlockchainRow, error) {
	row := q.db.QueryRowContext(ctx, insertBlockchain,
		arg.BlockchainID,
		arg.Active,
		arg.Altruist,
		arg.Blockchain,
		pq.Array(arg.BlockchainAliases),
		arg.ChainID,
		arg.ChainIDCheck,
		arg.Description,
		arg.EnforceResult,
		arg.LogLimitBlocks,
		arg.Network,
		arg.Path,
		arg.RequestTimeout,
		arg.Ticker,
	)
	var i InsertBlockchainRow
	err := row.Scan(&i.CreatedAt, &i.UpdatedAt)
	return i, err
}

const insertGatewayAAT = `-- name: InsertGatewayAAT :exec
INSERT into gateway_aat (
        application_id,
        address,
        client_public_key,
        private_key,
        public_key,
        signature,
        version
    )
VALUES (
        $1,
        $2,
        $3,
        $4,
        $5,
        $6,
        $7
    )
`

type InsertGatewayAATParams struct {
	ApplicationID   string         `json:"applicationID"`
	Address         string         `json:"address"`
	ClientPublicKey string         `json:"clientPublicKey"`
	PrivateKey      sql.NullString `json:"privateKey"`
	PublicKey       string         `json:"publicKey"`
	Signature       string         `json:"signature"`
	Version         sql.NullString `json:"version"`
}

func (q *Queries) InsertGatewayAAT(ctx context.Context, arg InsertGatewayAATParams) error {
	_, err := q.db.ExecContext(ctx, insertGatewayAAT,
		arg.ApplicationID,
		arg.Address,
		arg.ClientPublicKey,
		arg.PrivateKey,
		arg.PublicKey,
		arg.Signature,
		arg.Version,
	)
	return err
}

const insertGatewaySettings = `-- name: InsertGatewaySettings :exec
INSERT into gateway_settings (
        application_id,
        secret_key,
        secret_key_required,
        whitelist_contracts,
        whitelist_methods,
        whitelist_origins,
        whitelist_user_agents,
        whitelist_blockchains
    )
VALUES (
        $1,
        $2,
        $3,
        $4,
        $5,
        $6,
        $7,
        $8
    )
`

type InsertGatewaySettingsParams struct {
	ApplicationID        string         `json:"applicationID"`
	SecretKey            sql.NullString `json:"secretKey"`
	SecretKeyRequired    sql.NullBool   `json:"secretKeyRequired"`
	WhitelistContracts   sql.NullString `json:"whitelistContracts"`
	WhitelistMethods     sql.NullString `json:"whitelistMethods"`
	WhitelistOrigins     []string       `json:"whitelistOrigins"`
	WhitelistUserAgents  []string       `json:"whitelistUserAgents"`
	WhitelistBlockchains []string       `json:"whitelistBlockchains"`
}

func (q *Queries) InsertGatewaySettings(ctx context.Context, arg InsertGatewaySettingsParams) error {
	_, err := q.db.ExecContext(ctx, insertGatewaySettings,
		arg.ApplicationID,
		arg.SecretKey,
		arg.SecretKeyRequired,
		arg.WhitelistContracts,
		arg.WhitelistMethods,
		pq.Array(arg.WhitelistOrigins),
		pq.Array(arg.WhitelistUserAgents),
		pq.Array(arg.WhitelistBlockchains),
	)
	return err
}

const insertLbApps = `-- name: InsertLbApps :exec
INSERT into lb_apps (lb_id, app_id)
SELECT $1,
    unnest($2::VARCHAR [])
`

type InsertLbAppsParams struct {
	LbID   string   `json:"lbID"`
	AppIds []string `json:"appIds"`
}

func (q *Queries) InsertLbApps(ctx context.Context, arg InsertLbAppsParams) error {
	_, err := q.db.ExecContext(ctx, insertLbApps, arg.LbID, pq.Array(arg.AppIds))
	return err
}

const insertLoadBalancer = `-- name: InsertLoadBalancer :one
INSERT into loadbalancers (
        lb_id,
        name,
        user_id,
        request_timeout,
        gigastake,
        gigastake_redirect
    )
VALUES (
        $1,
        $2,
        $3,
        $4,
        $5,
        $6
    )
RETURNING created_at, updated_at
`

type InsertLoadBalancerParams struct {
	LbID              string         `json:"lbID"`
	Name              sql.NullString `json:"name"`
	UserID            sql.NullString `json:"userID"`
	RequestTimeout    sql.NullInt32  `json:"requestTimeout"`
	Gigastake         sql.NullBool   `json:"gigastake"`
	GigastakeRedirect sql.NullBool   `json:"gigastakeRedirect"`
}

type InsertLoadBalancerRow struct {
	CreatedAt time.Time `json:"createdAt"`
	UpdatedAt time.Time `json:"updatedAt"`
}

func (q *Queries) InsertLoadBalancer(ctx context.Context, arg InsertLoadBalancerParams) (InsertLoadBalancerRow, error) {
	row := q.db.QueryRowContext(ctx, insertLoadBalancer,
		arg.LbID,
		arg.Name,
		arg.UserID,
		arg.RequestTimeout,
		arg.Gigastake,
		arg.GigastakeRedirect,
	)
	var i InsertLoadBalancerRow
	err := row.Scan(&i.CreatedAt, &i.UpdatedAt)
	return i, err
}

const insertNotificationSettings = `-- name: InsertNotificationSettings :exec
INSERT into notification_settings (
        application_id,
        signed_up,
        on_quarter,
        on_half,
        on_three_quarters,
        on_full
    )
VALUES (
        $1,
        $2,
        $3,
        $4,
        $5,
        $6
    )
`

type InsertNotificationSettingsParams struct {
	ApplicationID   string       `json:"applicationID"`
	SignedUp        sql.NullBool `json:"signedUp"`
	OnQuarter       sql.NullBool `json:"onQuarter"`
	OnHalf          sql.NullBool `json:"onHalf"`
	OnThreeQuarters sql.NullBool `json:"onThreeQuarters"`
	OnFull          sql.NullBool `json:"onFull"`
}

func (q *Queries) InsertNotificationSettings(ctx context.Context, arg InsertNotificationSettingsParams) error {
	_, err := q.db.ExecContext(ctx, insertNotificationSettings,
		arg.ApplicationID,
		arg.SignedUp,
		arg.OnQuarter,
		arg.OnHalf,
		arg.OnThreeQuarters,
		arg.OnFull,
	)
	return err
}

const insertRedirect = `-- name: InsertRedirect :exec
INSERT into redirects (
        blockchain_id,
        alias,
        loadbalancer,
        domain
    )
VALUES (
        $1,
        $2,
        $3,
        $4
    )
`

type InsertRedirectParams struct {
	BlockchainID string `json:"blockchainID"`
	Alias        string `json:"alias"`
	Loadbalancer string `json:"loadbalancer"`
	Domain       string `json:"domain"`
}

func (q *Queries) InsertRedirect(ctx context.Context, arg InsertRedirectParams) error {
	_, err := q.db.ExecContext(ctx, insertRedirect,
		arg.BlockchainID,
		arg.Alias,
		arg.Loadbalancer,
		arg.Domain,
	)
	return err
}

const insertStickinessOptions = `-- name: InsertStickinessOptions :exec
INSERT INTO stickiness_options (
        lb_id,
        duration,
        sticky_max,
        stickiness,
        origins
    )
VALUES ($1, $2, $3, $4, $5)
`

type InsertStickinessOptionsParams struct {
	LbID       string         `json:"lbID"`
	Duration   sql.NullString `json:"duration"`
	StickyMax  sql.NullInt32  `json:"stickyMax"`
	Stickiness sql.NullBool   `json:"stickiness"`
	Origins    []string       `json:"origins"`
}

func (q *Queries) InsertStickinessOptions(ctx context.Context, arg InsertStickinessOptionsParams) error {
	_, err := q.db.ExecContext(ctx, insertStickinessOptions,
		arg.LbID,
		arg.Duration,
		arg.StickyMax,
		arg.Stickiness,
		pq.Array(arg.Origins),
	)
	return err
}

const insertSyncCheckOptions = `-- name: InsertSyncCheckOptions :exec
INSERT into sync_check_options (
        blockchain_id,
        synccheck,
        allowance,
        body,
        path,
        result_key
    )
VALUES (
        $1,
        $2,
        $3,
        $4,
        $5,
        $6
    )
`

type InsertSyncCheckOptionsParams struct {
	BlockchainID string         `json:"blockchainID"`
	Synccheck    sql.NullString `json:"synccheck"`
	Allowance    sql.NullInt32  `json:"allowance"`
	Body         sql.NullString `json:"body"`
	Path         sql.NullString `json:"path"`
	ResultKey    sql.NullString `json:"resultKey"`
}

func (q *Queries) InsertSyncCheckOptions(ctx context.Context, arg InsertSyncCheckOptionsParams) error {
	_, err := q.db.ExecContext(ctx, insertSyncCheckOptions,
		arg.BlockchainID,
		arg.Synccheck,
		arg.Allowance,
		arg.Body,
		arg.Path,
		arg.ResultKey,
	)
	return err
}

const removeApp = `-- name: RemoveApp :exec
UPDATE applications
SET status = COALESCE($2, status)
WHERE application_id = $1
`

type RemoveAppParams struct {
	ApplicationID string         `json:"applicationID"`
	Status        sql.NullString `json:"status"`
}

func (q *Queries) RemoveApp(ctx context.Context, arg RemoveAppParams) error {
	_, err := q.db.ExecContext(ctx, removeApp, arg.ApplicationID, arg.Status)
	return err
}

const removeLB = `-- name: RemoveLB :exec
UPDATE loadbalancers
SET user_id = ''
WHERE lb_id = $1
`

func (q *Queries) RemoveLB(ctx context.Context, lbID string) error {
	_, err := q.db.ExecContext(ctx, removeLB, lbID)
	return err
}

const selectAppLimit = `-- name: SelectAppLimit :one
SELECT application_id,
    pay_plan,
    custom_limit
FROM app_limits
WHERE application_id = $1
`

type SelectAppLimitRow struct {
	ApplicationID string        `json:"applicationID"`
	PayPlan       string        `json:"payPlan"`
	CustomLimit   sql.NullInt32 `json:"customLimit"`
}

func (q *Queries) SelectAppLimit(ctx context.Context, applicationID string) (SelectAppLimitRow, error) {
	row := q.db.QueryRowContext(ctx, selectAppLimit, applicationID)
	var i SelectAppLimitRow
	err := row.Scan(&i.ApplicationID, &i.PayPlan, &i.CustomLimit)
	return i, err
}

const selectApplications = `-- name: SelectApplications :many
SELECT a.application_id,
    a.contact_email,
    a.description,
    a.dummy,
    a.name,
    a.owner,
    a.status,
    a.url,
    a.user_id,
    a.first_date_surpassed,
    ga.address AS ga_address,
    ga.client_public_key AS ga_client_public_key,
    ga.private_key AS ga_private_key,
    ga.public_key AS ga_public_key,
    ga.signature AS ga_signature,
    ga.version AS ga_version,
    gs.secret_key,
    gs.secret_key_required,
    gs.whitelist_blockchains,
    gs.whitelist_contracts,
    gs.whitelist_methods,
    gs.whitelist_origins,
    gs.whitelist_user_agents,
    ns.signed_up,
    ns.on_quarter,
    ns.on_half,
    ns.on_three_quarters,
    ns.on_full,
    al.custom_limit,
    al.pay_plan,
    pp.daily_limit as plan_limit,
    a.created_at,
    a.updated_at
FROM applications AS a
    LEFT JOIN gateway_aat AS ga ON a.application_id = ga.application_id
    LEFT JOIN gateway_settings AS gs ON a.application_id = gs.application_id
    LEFT JOIN notification_settings AS ns ON a.application_id = ns.application_id
    LEFT JOIN app_limits AS al ON a.application_id = al.application_id
    LEFT JOIN pay_plans AS pp ON al.pay_plan = pp.plan_type
ORDER BY a.application_id ASC
`

type SelectApplicationsRow struct {
	ApplicationID        string         `json:"applicationID"`
	ContactEmail         sql.NullString `json:"contactEmail"`
	Description          sql.NullString `json:"description"`
	Dummy                sql.NullBool   `json:"dummy"`
	Name                 sql.NullString `json:"name"`
	Owner                sql.NullString `json:"owner"`
	Status               sql.NullString `json:"status"`
	Url                  sql.NullString `json:"url"`
	UserID               sql.NullString `json:"userID"`
	FirstDateSurpassed   sql.NullTime   `json:"firstDateSurpassed"`
	GaAddress            sql.NullString `json:"gaAddress"`
	GaClientPublicKey    sql.NullString `json:"gaClientPublicKey"`
	GaPrivateKey         sql.NullString `json:"gaPrivateKey"`
	GaPublicKey          sql.NullString `json:"gaPublicKey"`
	GaSignature          sql.NullString `json:"gaSignature"`
	GaVersion            sql.NullString `json:"gaVersion"`
	SecretKey            sql.NullString `json:"secretKey"`
	SecretKeyRequired    sql.NullBool   `json:"secretKeyRequired"`
	WhitelistBlockchains []string       `json:"whitelistBlockchains"`
	WhitelistContracts   sql.NullString `json:"whitelistContracts"`
	WhitelistMethods     sql.NullString `json:"whitelistMethods"`
	WhitelistOrigins     []string       `json:"whitelistOrigins"`
	WhitelistUserAgents  []string       `json:"whitelistUserAgents"`
	SignedUp             sql.NullBool   `json:"signedUp"`
	OnQuarter            sql.NullBool   `json:"onQuarter"`
	OnHalf               sql.NullBool   `json:"onHalf"`
	OnThreeQuarters      sql.NullBool   `json:"onThreeQuarters"`
	OnFull               sql.NullBool   `json:"onFull"`
	CustomLimit          sql.NullInt32  `json:"customLimit"`
	PayPlan              sql.NullString `json:"payPlan"`
	PlanLimit            sql.NullInt32  `json:"planLimit"`
	CreatedAt            time.Time      `json:"createdAt"`
	UpdatedAt            time.Time      `json:"updatedAt"`
}

func (q *Queries) SelectApplications(ctx context.Context) ([]SelectApplicationsRow, error) {
	rows, err := q.db.QueryContext(ctx, selectApplications)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectApplicationsRow
	for rows.Next() {
		var i SelectApplicationsRow
		if err := rows.Scan(
			&i.ApplicationID,
			&i.ContactEmail,
			&i.Description,
			&i.Dummy,
			&i.Name,
			&i.Owner,
			&i.Status,
			&i.Url,
			&i.UserID,
			&i.FirstDateSurpassed,
			&i.GaAddress,
			&i.GaClientPublicKey,
			&i.GaPrivateKey,
			&i.GaPublicKey,
			&i.GaSignature,
			&i.GaVersion,
			&i.SecretKey,
			&i.SecretKeyRequired,
			pq.Array(&i.WhitelistBlockchains),
			&i.WhitelistContracts,
			&i.WhitelistMethods,
			pq.Array(&i.WhitelistOrigins),
			pq.Array(&i.WhitelistUserAgents),
			&i.SignedUp,
			&i.OnQuarter,
			&i.OnHalf,
			&i.OnThreeQuarters,
			&i.OnFull,
			&i.CustomLimit,
			&i.PayPlan,
			&i.PlanLimit,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectBlockchains = `-- name: SelectBlockchains :many
SELECT b.blockchain_id,
    b.altruist,
    b.blockchain,
    b.blockchain_aliases,
    b.chain_id,
    b.chain_id_check,
    b.description,
    b.enforce_result,
    b.log_limit_blocks,
    b.network,
    b.path,
    b.request_timeout,
    b.ticker,
    b.active,
    s.synccheck as s_sync_check,
    s.allowance as s_allowance,
    s.body as s_body,
    s.path as s_path,
    s.result_key as s_result_key,
    COALESCE(redirects.r, '[]') AS redirects,
    b.created_at,
    b.updated_at
FROM blockchains as b
    LEFT JOIN sync_check_options AS s ON b.blockchain_id = s.blockchain_id
    LEFT JOIN LATERAL (
        SELECT json_agg(
                json_build_object(
                    'alias',
                    r.alias,
                    'loadBalancerID',
                    r.loadbalancer,
                    'domain',
                    r.domain
                )
            ) AS r
        FROM redirects AS r
        WHERE b.blockchain_id = r.blockchain_id
    ) redirects ON true
ORDER BY b.blockchain_id ASC
`

type SelectBlockchainsRow struct {
	BlockchainID      string          `json:"blockchainID"`
	Altruist          sql.NullString  `json:"altruist"`
	Blockchain        sql.NullString  `json:"blockchain"`
	BlockchainAliases []string        `json:"blockchainAliases"`
	ChainID           sql.NullString  `json:"chainID"`
	ChainIDCheck      sql.NullString  `json:"chainIDCheck"`
	Description       sql.NullString  `json:"description"`
	EnforceResult     sql.NullString  `json:"enforceResult"`
	LogLimitBlocks    sql.NullInt32   `json:"logLimitBlocks"`
	Network           sql.NullString  `json:"network"`
	Path              sql.NullString  `json:"path"`
	RequestTimeout    sql.NullInt32   `json:"requestTimeout"`
	Ticker            sql.NullString  `json:"ticker"`
	Active            sql.NullBool    `json:"active"`
	SSyncCheck        sql.NullString  `json:"sSyncCheck"`
	SAllowance        sql.NullInt32   `json:"sAllowance"`
	SBody             sql.NullString  `json:"sBody"`
	SPath             sql.NullString  `json:"sPath"`
	SResultKey        sql.NullString  `json:"sResultKey"`
	Redirects         json.RawMessage `json:"redirects"`
	CreatedAt         time.Time       `json:"createdAt"`
	UpdatedAt         time.Time       `json:"updatedAt"`
}

func (q *Queries) SelectBlockchains(ctx context.Context) ([]SelectBlockchainsRow, error) {
	rows, err := q.db.QueryContext(ctx, selectBlockchains)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectBlockchainsRow
	for rows.Next() {
		var i SelectBlockchainsRow
		if err := rows.Scan(
			&i.BlockchainID,
			&i.Altruist,
			&i.Blockchain,
			pq.Array(&i.BlockchainAliases),
			&i.ChainID,
			&i.ChainIDCheck,
			&i.Description,
			&i.EnforceResult,
			&i.LogLimitBlocks,
			&i.Network,
			&i.Path,
			&i.RequestTimeout,
			&i.Ticker,
			&i.Active,
			&i.SSyncCheck,
			&i.SAllowance,
			&i.SBody,
			&i.SPath,
			&i.SResultKey,
			&i.Redirects,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectGatewaySettings = `-- name: SelectGatewaySettings :one
SELECT application_id,
    secret_key,
    secret_key_required,
    whitelist_blockchains,
    whitelist_contracts,
    whitelist_methods,
    whitelist_origins,
    whitelist_user_agents
FROM gateway_settings
WHERE application_id = $1
`

type SelectGatewaySettingsRow struct {
	ApplicationID        string         `json:"applicationID"`
	SecretKey            sql.NullString `json:"secretKey"`
	SecretKeyRequired    sql.NullBool   `json:"secretKeyRequired"`
	WhitelistBlockchains []string       `json:"whitelistBlockchains"`
	WhitelistContracts   sql.NullString `json:"whitelistContracts"`
	WhitelistMethods     sql.NullString `json:"whitelistMethods"`
	WhitelistOrigins     []string       `json:"whitelistOrigins"`
	WhitelistUserAgents  []string       `json:"whitelistUserAgents"`
}

func (q *Queries) SelectGatewaySettings(ctx context.Context, applicationID string) (SelectGatewaySettingsRow, error) {
	row := q.db.QueryRowContext(ctx, selectGatewaySettings, applicationID)
	var i SelectGatewaySettingsRow
	err := row.Scan(
		&i.ApplicationID,
		&i.SecretKey,
		&i.SecretKeyRequired,
		pq.Array(&i.WhitelistBlockchains),
		&i.WhitelistContracts,
		&i.WhitelistMethods,
		pq.Array(&i.WhitelistOrigins),
		pq.Array(&i.WhitelistUserAgents),
	)
	return i, err
}

const selectLoadBalancers = `-- name: SelectLoadBalancers :many
SELECT lb.lb_id,
    lb.name,
    lb.created_at,
    lb.updated_at,
    lb.request_timeout,
    lb.gigastake,
    lb.gigastake_redirect,
    lb.user_id,
    so.duration,
    so.sticky_max,
    so.stickiness,
    so.origins,
    STRING_AGG(la.app_id, ',') AS app_ids
FROM loadbalancers AS lb
    LEFT JOIN stickiness_options AS so ON lb.lb_id = so.lb_id
    LEFT JOIN lb_apps AS la ON lb.lb_id = la.lb_id
GROUP BY lb.lb_id,
    lb.lb_id,
    lb.name,
    lb.created_at,
    lb.updated_at,
    lb.request_timeout,
    lb.gigastake,
    lb.gigastake_redirect,
    lb.user_id,
    so.duration,
    so.sticky_max,
    so.stickiness,
    so.origins
ORDER BY lb_id ASC
`

type SelectLoadBalancersRow struct {
	LbID              string         `json:"lbID"`
	Name              sql.NullString `json:"name"`
	CreatedAt         time.Time      `json:"createdAt"`
	UpdatedAt         time.Time      `json:"updatedAt"`
	RequestTimeout    sql.NullInt32  `json:"requestTimeout"`
	Gigastake         sql.NullBool   `json:"gigastake"`
	GigastakeRedirect sql.NullBool   `json:"gigastakeRedirect"`
	UserID            sql.NullString `json:"userID"`
	Duration          sql.NullString `json:"duration"`
	StickyMax         sql.NullInt32  `json:"stickyMax"`
	Stickiness        sql.NullBool   `json:"stickiness"`
	Origins           []string       `json:"origins"`
	AppIds            []byte         `json:"appIds"`
}

func (q *Queries) SelectLoadBalancers(ctx context.Context) ([]SelectLoadBalancersRow, error) {
	rows, err := q.db.QueryContext(ctx, selectLoadBalancers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectLoadBalancersRow
	for rows.Next() {
		var i SelectLoadBalancersRow
		if err := rows.Scan(
			&i.LbID,
			&i.Name,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RequestTimeout,
			&i.Gigastake,
			&i.GigastakeRedirect,
			&i.UserID,
			&i.Duration,
			&i.StickyMax,
			&i.Stickiness,
			pq.Array(&i.Origins),
			&i.AppIds,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectNotificationSettings = `-- name: SelectNotificationSettings :one
SELECT application_id,
    signed_up,
    on_quarter,
    on_half,
    on_three_quarters,
    on_full
FROM notification_settings
WHERE application_id = $1
`

type SelectNotificationSettingsRow struct {
	ApplicationID   string       `json:"applicationID"`
	SignedUp        sql.NullBool `json:"signedUp"`
	OnQuarter       sql.NullBool `json:"onQuarter"`
	OnHalf          sql.NullBool `json:"onHalf"`
	OnThreeQuarters sql.NullBool `json:"onThreeQuarters"`
	OnFull          sql.NullBool `json:"onFull"`
}

func (q *Queries) SelectNotificationSettings(ctx context.Context, applicationID string) (SelectNotificationSettingsRow, error) {
	row := q.db.QueryRowContext(ctx, selectNotificationSettings, applicationID)
	var i SelectNotificationSettingsRow
	err := row.Scan(
		&i.ApplicationID,
		&i.SignedUp,
		&i.OnQuarter,
		&i.OnHalf,
		&i.OnThreeQuarters,
		&i.OnFull,
	)
	return i, err
}

const selectOneApplication = `-- name: SelectOneApplication :one
SELECT a.application_id,
    a.contact_email,
    a.description,
    a.dummy,
    a.name,
    a.owner,
    a.status,
    a.url,
    a.user_id,
    a.first_date_surpassed,
    ga.address AS ga_address,
    ga.client_public_key AS ga_client_public_key,
    ga.private_key AS ga_private_key,
    ga.public_key AS ga_public_key,
    ga.signature AS ga_signature,
    ga.version AS ga_version,
    gs.secret_key,
    gs.secret_key_required,
    gs.whitelist_blockchains,
    gs.whitelist_contracts,
    gs.whitelist_methods,
    gs.whitelist_origins,
    gs.whitelist_user_agents,
    ns.signed_up,
    ns.on_quarter,
    ns.on_half,
    ns.on_three_quarters,
    ns.on_full,
    al.custom_limit,
    al.pay_plan,
    pp.daily_limit as plan_limit,
    a.created_at,
    a.updated_at
FROM applications AS a
    LEFT JOIN gateway_aat AS ga ON a.application_id = ga.application_id
    LEFT JOIN gateway_settings AS gs ON a.application_id = gs.application_id
    LEFT JOIN notification_settings AS ns ON a.application_id = ns.application_id
    LEFT JOIN app_limits AS al ON a.application_id = al.application_id
    LEFT JOIN pay_plans AS pp ON al.pay_plan = pp.plan_type
WHERE a.application_id = $1
ORDER BY a.application_id ASC
`

type SelectOneApplicationRow struct {
	ApplicationID        string         `json:"applicationID"`
	ContactEmail         sql.NullString `json:"contactEmail"`
	Description          sql.NullString `json:"description"`
	Dummy                sql.NullBool   `json:"dummy"`
	Name                 sql.NullString `json:"name"`
	Owner                sql.NullString `json:"owner"`
	Status               sql.NullString `json:"status"`
	Url                  sql.NullString `json:"url"`
	UserID               sql.NullString `json:"userID"`
	FirstDateSurpassed   sql.NullTime   `json:"firstDateSurpassed"`
	GaAddress            sql.NullString `json:"gaAddress"`
	GaClientPublicKey    sql.NullString `json:"gaClientPublicKey"`
	GaPrivateKey         sql.NullString `json:"gaPrivateKey"`
	GaPublicKey          sql.NullString `json:"gaPublicKey"`
	GaSignature          sql.NullString `json:"gaSignature"`
	GaVersion            sql.NullString `json:"gaVersion"`
	SecretKey            sql.NullString `json:"secretKey"`
	SecretKeyRequired    sql.NullBool   `json:"secretKeyRequired"`
	WhitelistBlockchains []string       `json:"whitelistBlockchains"`
	WhitelistContracts   sql.NullString `json:"whitelistContracts"`
	WhitelistMethods     sql.NullString `json:"whitelistMethods"`
	WhitelistOrigins     []string       `json:"whitelistOrigins"`
	WhitelistUserAgents  []string       `json:"whitelistUserAgents"`
	SignedUp             sql.NullBool   `json:"signedUp"`
	OnQuarter            sql.NullBool   `json:"onQuarter"`
	OnHalf               sql.NullBool   `json:"onHalf"`
	OnThreeQuarters      sql.NullBool   `json:"onThreeQuarters"`
	OnFull               sql.NullBool   `json:"onFull"`
	CustomLimit          sql.NullInt32  `json:"customLimit"`
	PayPlan              sql.NullString `json:"payPlan"`
	PlanLimit            sql.NullInt32  `json:"planLimit"`
	CreatedAt            time.Time      `json:"createdAt"`
	UpdatedAt            time.Time      `json:"updatedAt"`
}

func (q *Queries) SelectOneApplication(ctx context.Context, applicationID string) (SelectOneApplicationRow, error) {
	row := q.db.QueryRowContext(ctx, selectOneApplication, applicationID)
	var i SelectOneApplicationRow
	err := row.Scan(
		&i.ApplicationID,
		&i.ContactEmail,
		&i.Description,
		&i.Dummy,
		&i.Name,
		&i.Owner,
		&i.Status,
		&i.Url,
		&i.UserID,
		&i.FirstDateSurpassed,
		&i.GaAddress,
		&i.GaClientPublicKey,
		&i.GaPrivateKey,
		&i.GaPublicKey,
		&i.GaSignature,
		&i.GaVersion,
		&i.SecretKey,
		&i.SecretKeyRequired,
		pq.Array(&i.WhitelistBlockchains),
		&i.WhitelistContracts,
		&i.WhitelistMethods,
		pq.Array(&i.WhitelistOrigins),
		pq.Array(&i.WhitelistUserAgents),
		&i.SignedUp,
		&i.OnQuarter,
		&i.OnHalf,
		&i.OnThreeQuarters,
		&i.OnFull,
		&i.CustomLimit,
		&i.PayPlan,
		&i.PlanLimit,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const selectOneLoadBalancer = `-- name: SelectOneLoadBalancer :one
SELECT lb.lb_id,
    lb.name,
    lb.created_at,
    lb.updated_at,
    lb.request_timeout,
    lb.gigastake,
    lb.gigastake_redirect,
    lb.user_id,
    so.duration,
    so.sticky_max,
    so.stickiness,
    so.origins,
    STRING_AGG(la.app_id, ',') AS app_ids
FROM loadbalancers AS lb
    LEFT JOIN stickiness_options AS so ON lb.lb_id = so.lb_id
    LEFT JOIN lb_apps AS la ON lb.lb_id = la.lb_id
WHERE lb.lb_id = $1
GROUP BY lb.lb_id,
    lb.lb_id,
    lb.name,
    lb.created_at,
    lb.updated_at,
    lb.request_timeout,
    lb.gigastake,
    lb.gigastake_redirect,
    lb.user_id,
    so.duration,
    so.sticky_max,
    so.stickiness,
    so.origins
`

type SelectOneLoadBalancerRow struct {
	LbID              string         `json:"lbID"`
	Name              sql.NullString `json:"name"`
	CreatedAt         time.Time      `json:"createdAt"`
	UpdatedAt         time.Time      `json:"updatedAt"`
	RequestTimeout    sql.NullInt32  `json:"requestTimeout"`
	Gigastake         sql.NullBool   `json:"gigastake"`
	GigastakeRedirect sql.NullBool   `json:"gigastakeRedirect"`
	UserID            sql.NullString `json:"userID"`
	Duration          sql.NullString `json:"duration"`
	StickyMax         sql.NullInt32  `json:"stickyMax"`
	Stickiness        sql.NullBool   `json:"stickiness"`
	Origins           []string       `json:"origins"`
	AppIds            []byte         `json:"appIds"`
}

func (q *Queries) SelectOneLoadBalancer(ctx context.Context, lbID string) (SelectOneLoadBalancerRow, error) {
	row := q.db.QueryRowContext(ctx, selectOneLoadBalancer, lbID)
	var i SelectOneLoadBalancerRow
	err := row.Scan(
		&i.LbID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.RequestTimeout,
		&i.Gigastake,
		&i.GigastakeRedirect,
		&i.UserID,
		&i.Duration,
		&i.StickyMax,
		&i.Stickiness,
		pq.Array(&i.Origins),
		&i.AppIds,
	)
	return i, err
}

const selectPayPlans = `-- name: SelectPayPlans :many
SELECT plan_type,
    daily_limit
FROM pay_plans
ORDER BY plan_type ASC
`

type SelectPayPlansRow struct {
	PlanType   string `json:"planType"`
	DailyLimit int32  `json:"dailyLimit"`
}

func (q *Queries) SelectPayPlans(ctx context.Context) ([]SelectPayPlansRow, error) {
	rows, err := q.db.QueryContext(ctx, selectPayPlans)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectPayPlansRow
	for rows.Next() {
		var i SelectPayPlansRow
		if err := rows.Scan(&i.PlanType, &i.DailyLimit); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateFirstDateSurpassed = `-- name: UpdateFirstDateSurpassed :exec
UPDATE applications
SET first_date_surpassed = $1
WHERE application_id = ANY ($2::VARCHAR [])
`

type UpdateFirstDateSurpassedParams struct {
	FirstDateSurpassed sql.NullTime `json:"firstDateSurpassed"`
	ApplicationIds     []string     `json:"applicationIds"`
}

func (q *Queries) UpdateFirstDateSurpassed(ctx context.Context, arg UpdateFirstDateSurpassedParams) error {
	_, err := q.db.ExecContext(ctx, updateFirstDateSurpassed, arg.FirstDateSurpassed, pq.Array(arg.ApplicationIds))
	return err
}

const updateLB = `-- name: UpdateLB :exec
UPDATE loadbalancers as l
SET name = COALESCE($2, l.name)
WHERE l.lb_id = $1
`

type UpdateLBParams struct {
	LbID string         `json:"lbID"`
	Name sql.NullString `json:"name"`
}

func (q *Queries) UpdateLB(ctx context.Context, arg UpdateLBParams) error {
	_, err := q.db.ExecContext(ctx, updateLB, arg.LbID, arg.Name)
	return err
}

const upsertAppLimit = `-- name: UpsertAppLimit :exec
INSERT INTO app_limits as al (
        application_id,
        pay_plan,
        custom_limit
    )
VALUES ($1, $2, $3) ON CONFLICT (application_id) DO
UPDATE
SET pay_plan = COALESCE(EXCLUDED.pay_plan, al.pay_plan),
    custom_limit = COALESCE(EXCLUDED.custom_limit, al.custom_limit)
`

type UpsertAppLimitParams struct {
	ApplicationID string        `json:"applicationID"`
	PayPlan       string        `json:"payPlan"`
	CustomLimit   sql.NullInt32 `json:"customLimit"`
}

func (q *Queries) UpsertAppLimit(ctx context.Context, arg UpsertAppLimitParams) error {
	_, err := q.db.ExecContext(ctx, upsertAppLimit, arg.ApplicationID, arg.PayPlan, arg.CustomLimit)
	return err
}

const upsertApplication = `-- name: UpsertApplication :exec
INSERT INTO applications as a (
        application_id,
        name,
        status,
        first_date_surpassed
    )
VALUES ($1, $2, $3, $4) ON CONFLICT (application_id) DO
UPDATE
SET name = COALESCE(EXCLUDED.name, a.name),
    status = COALESCE(EXCLUDED.status, a.status),
    first_date_surpassed = COALESCE(
        EXCLUDED.first_date_surpassed,
        a.first_date_surpassed
    )
`

type UpsertApplicationParams struct {
	ApplicationID      string         `json:"applicationID"`
	Name               sql.NullString `json:"name"`
	Status             sql.NullString `json:"status"`
	FirstDateSurpassed sql.NullTime   `json:"firstDateSurpassed"`
}

func (q *Queries) UpsertApplication(ctx context.Context, arg UpsertApplicationParams) error {
	_, err := q.db.ExecContext(ctx, upsertApplication,
		arg.ApplicationID,
		arg.Name,
		arg.Status,
		arg.FirstDateSurpassed,
	)
	return err
}

const upsertGatewaySettings = `-- name: UpsertGatewaySettings :exec
INSERT INTO gateway_settings as gs (
        application_id,
        secret_key,
        secret_key_required,
        whitelist_contracts,
        whitelist_methods,
        whitelist_origins,
        whitelist_user_agents,
        whitelist_blockchains
    )
VALUES ($1, $2, $3, $4, $5, $6, $7, $8) ON CONFLICT (application_id) DO
UPDATE
SET secret_key = COALESCE(EXCLUDED.secret_key, gs.secret_key),
    secret_key_required = COALESCE(
        EXCLUDED.secret_key_required,
        gs.secret_key_required
    ),
    whitelist_contracts = COALESCE(
        EXCLUDED.whitelist_contracts,
        gs.whitelist_contracts
    ),
    whitelist_methods = COALESCE(EXCLUDED.whitelist_methods, gs.whitelist_methods),
    whitelist_origins = COALESCE(EXCLUDED.whitelist_origins, gs.whitelist_origins),
    whitelist_user_agents = COALESCE(
        EXCLUDED.whitelist_user_agents,
        gs.whitelist_user_agents
    ),
    whitelist_blockchains = COALESCE(
        EXCLUDED.whitelist_blockchains,
        gs.whitelist_blockchains
    )
`

type UpsertGatewaySettingsParams struct {
	ApplicationID        string         `json:"applicationID"`
	SecretKey            sql.NullString `json:"secretKey"`
	SecretKeyRequired    sql.NullBool   `json:"secretKeyRequired"`
	WhitelistContracts   sql.NullString `json:"whitelistContracts"`
	WhitelistMethods     sql.NullString `json:"whitelistMethods"`
	WhitelistOrigins     []string       `json:"whitelistOrigins"`
	WhitelistUserAgents  []string       `json:"whitelistUserAgents"`
	WhitelistBlockchains []string       `json:"whitelistBlockchains"`
}

func (q *Queries) UpsertGatewaySettings(ctx context.Context, arg UpsertGatewaySettingsParams) error {
	_, err := q.db.ExecContext(ctx, upsertGatewaySettings,
		arg.ApplicationID,
		arg.SecretKey,
		arg.SecretKeyRequired,
		arg.WhitelistContracts,
		arg.WhitelistMethods,
		pq.Array(arg.WhitelistOrigins),
		pq.Array(arg.WhitelistUserAgents),
		pq.Array(arg.WhitelistBlockchains),
	)
	return err
}

const upsertNotificationSettings = `-- name: UpsertNotificationSettings :exec
INSERT INTO notification_settings as ns (
        application_id,
        signed_up,
        on_quarter,
        on_half,
        on_three_quarters,
        on_full
    )
VALUES ($1, $2, $3, $4, $5, $6) ON CONFLICT (application_id) DO
UPDATE
SET signed_up = COALESCE(EXCLUDED.signed_up, ns.signed_up),
    on_quarter = COALESCE(EXCLUDED.on_quarter, ns.on_quarter),
    on_half = COALESCE(EXCLUDED.on_half, ns.on_half),
    on_three_quarters = COALESCE(EXCLUDED.on_three_quarters, ns.on_three_quarters),
    on_full = COALESCE(EXCLUDED.on_full, ns.on_full)
`

type UpsertNotificationSettingsParams struct {
	ApplicationID   string       `json:"applicationID"`
	SignedUp        sql.NullBool `json:"signedUp"`
	OnQuarter       sql.NullBool `json:"onQuarter"`
	OnHalf          sql.NullBool `json:"onHalf"`
	OnThreeQuarters sql.NullBool `json:"onThreeQuarters"`
	OnFull          sql.NullBool `json:"onFull"`
}

func (q *Queries) UpsertNotificationSettings(ctx context.Context, arg UpsertNotificationSettingsParams) error {
	_, err := q.db.ExecContext(ctx, upsertNotificationSettings,
		arg.ApplicationID,
		arg.SignedUp,
		arg.OnQuarter,
		arg.OnHalf,
		arg.OnThreeQuarters,
		arg.OnFull,
	)
	return err
}

const upsertStickinessOptions = `-- name: UpsertStickinessOptions :exec
INSERT INTO stickiness_options as so (
        lb_id,
        duration,
        sticky_max,
        stickiness,
        origins
    )
VALUES ($1, $2, $3, $4, $5) ON CONFLICT (lb_id) DO
UPDATE
SET duration = COALESCE(EXCLUDED.duration, so.duration),
    sticky_max = COALESCE(EXCLUDED.sticky_max, so.sticky_max),
    stickiness = COALESCE(EXCLUDED.stickiness, so.stickiness),
    origins = COALESCE(EXCLUDED.origins, so.origins)
`

type UpsertStickinessOptionsParams struct {
	LbID       string         `json:"lbID"`
	Duration   sql.NullString `json:"duration"`
	StickyMax  sql.NullInt32  `json:"stickyMax"`
	Stickiness sql.NullBool   `json:"stickiness"`
	Origins    []string       `json:"origins"`
}

func (q *Queries) UpsertStickinessOptions(ctx context.Context, arg UpsertStickinessOptionsParams) error {
	_, err := q.db.ExecContext(ctx, upsertStickinessOptions,
		arg.LbID,
		arg.Duration,
		arg.StickyMax,
		arg.Stickiness,
		pq.Array(arg.Origins),
	)
	return err
}
